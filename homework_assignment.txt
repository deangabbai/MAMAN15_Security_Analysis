מטלת מנחה (ממ"ן) 15


הקורס: תכנות מערכות דפנסיבי - 20937
חומר הלימוד למטלה: יחידות 1-7

משקל המטלה: 14 נקודות	מספר השאלות: 2 + 2 בונוס
מועד אחרון להגשה: 23.10.2025	סמסטר: 2025ג


שאלה 1 )80%(
בתרגיל זה תממשו תוכנת מסרים מיידים בשם ,MessageU בדומה לוואטסאפ, פייסבוק מסנג'ר וכו.' את השרת תכתבו בשפת python ואילו את תוכנת הלקוח בשפת .C++

חשוב!
קראו היטב את כל המטלה לפני תחילת העבודה. וודאו שאתם מבינים היטב את פרוטוקול התקשורת ואת המבנה של תוכנת השרת והלקוח.


ארכיטקטורה
ארכיטקטורת התוכנה שנפתח מבוססת על שרת-לקוח. כלומר, ההודעות נשלחות ראשית לשרת, ולאחר מכן, השרת מפנה לכל לקוח את ההודעה המתאימה.
תוכנת הלקוח "תמשוך" הודעות מהשרת באופן מחזורי request( .)pull
מאפיין זה מאפשר לשלוח הודעות ללקוחות במצב מחובר )online( וגם במצב מנותק .)offline(
בנוסף, נתמוך בהצפנה מקצה לקצה 1 encryption( ,)end-to-end כלומר, ההודעות מוצפנות בצד הלקוח ונשלחות בצורה מוצפנת, כך שאף אחד לא יכול לפענח את המידע למעט לקוח היעד (גם לא השרת.)

Figure 1 ארכיטקטורת שרת-לקוח שתומכת בהצפנה מקצה לקצה

 https://en.wikipedia.org/wiki/End-to-end_encryption1
 
שרת
תפקיד השרת לנהל את רשימת המשתמשים הרשומים לשירות ולאפשר להם להחליף ביניהם הודעות מסוגים שונים.
 
השרת יכתב בשפת .python
השרת יתמוך בפרוטוקול חסר מצב )stateless( ,2 כלומר, לא ישמור מידע בין בקשה לבקשה (כל בקשה עומדת בפני עצמה.)
השרת יתמוך בריבוי משתמשים ע"י תהליכונים )threads( או ע"י .selector גרסת השרת תהיה .1
 
.א
.ב
.ג
.ד
פורט
 
השרת יקרא את מספר הפורט מתוך קובץ טקסט  בצורה הבאה:
 
myport.info :הקובץ שם
מיקום הקובץ: באותה תיקיה של קבצי הקוד של השרת תוכן הקובץ: מספר פורט
לדוגמא:
1234
אם הקובץ לא קיים, יש להוציא הודעת אזהרה ולפעול עם פורט ברירת מחדל .1357
 
-
-
-

-
נתונים
 
השרת ישמור את נתוני הלקוחות וההודעות בזיכרון .)RAM(
מומלץ להגדיר מחלקה עבור רשומת לקוח ומחלקה עבור רשומת הודעה בהתאם למבנה הטבלאות המוגדר בסעיף "בונוס."


*בונוס 10( נקודות*)
שמירת הנתונים תעשה ע"י טבלאות SQL בקובץ בשם .defensive.db אם בחרתם לממש את הבונוס, גרסת השרת תהיה .2
שימו לב: בתחילת הריצה של השרת, אם הקובץ לא קיים יש ליצור אותו. באותו אופן, אם טבלה לא קיימת, יש ליצור אותה.


מידע על הלקוחות ישמר בטבלה בשם clients מבנה הטבלה:
הערות	סוג	שם
מזהה ייחודי עבור כל לקוח. אינדקס	16 בתים 128( ביט)	ID
מחרוזת ASCII המייצגת שם משתמש.
(null terminated) !מסיים תו כולל	מחרוזת 255( בתים)	UserName
מפתח ציבורי של לקוח	160 בתים	PublicKey
הזמן בו התקבלה בקשה אחרונה מלקוח	תאריך ושעה	LastSeen

מידע על הודעות ישמר בטבלה בשם messages מבנה הטבלה:
הערות	סוג	שם

 https://en.wikipedia.org/wiki/Stateless_protocol :מצב חסר פרוטוקול על כאן קראו 2
 
אינדקס	4 בתים	ID
מזהה ייחודי של המקבל	16 בתים	ToClient
מזהה ייחודי של השולח	16 בתים	FromClient
סוג ההודעה	בית	Type
תוכן ההודעה	Blob	Content

אופן פעולת השרת
.1 קורא את הפורט מתוך הקובץ myport.info .2  ממתין לבקשות מלקוחות בלולאה אין סופית
.3  בעת קבלת בקשה מפענח את הבקשה בהתאם לפרוטוקול:
א.  בקשה לרישום: במידה ושם המשתמש המבוקש כבר קיים, השרת יחזיר שגיאה. אחרת, השרת ייצר UUID חדש עובר המשתמש, ישמור את הנתונים בזיכרון (או בבסיס הנתונים) ויחזיר תשובת הצלחה
ב. בקשת לרשימת לקוחות: השרת יחזיר את רשימת הלקוחות לפי הפרוטוקול. ג.  בקשת שליחת הודעה תטופל באופן הבא:
השרת יחלץ את סוג ההודעה ואת תוכן ההודעה (מתוך ה- )payload וישמור אותו בזיכרון (או בבסיס הנתונים)
ד.  בקשת שליפת הודעות ממתינות תטופל באופן הבא:
השרת ישלוף הודעות מתוך הזיכרון (או בסיס הנתונים) וישלח תשובה ללקוח
שימו לב! הודעות שנשלחו בהצלחה ללקוח ימחקו.



לקוח
תוכנת הלקוח תאפשר למשתמש לשלוח הודעה למשתמש אחר אשר רשום בשרת. שימו לב! ניתן לשלוח הודעה לכל משתמש רשום במערכת (אין "אנשי קשר.)"

א.  תוכנת הלקוח תכתב בשפת C++
ב. הלקוח ירוץ במצב מסוף )console( ויקבל קלט מהמשתמש stdin( או )cin לביצוע הפעולות השונות.
ג.  הלקוח יתמוך בהצפנה מקצה לקצה ד. גירסת הלקוח תהיה 1


כתובת השרת והפורט
הלקוח יקרא את כתובת השרת והפורט מתוך קובץ טקסט  בצורה הבאה:
server.info :הקובץ שם	-
-  מיקום הקובץ: בתיקיה של קובץ ההרצה ).exe(
-  תוכן הקובץ: כתובת IP + נקודותיים + מספר פורט לדוגמא:
127.0.0.1:1234

שם ומזהה ייחודי 3


3 בתרגיל זה נעשה שימוש במזהה ייחודי גלובלי .)UUID( לקריאה נוספת:
 https://en.wikipedia.org/wiki/Universally_unique_identifier
 
הלקוח ישמור ויקרא את השם והמזהה הייחודי שלו מתוך קובץ טקסט בצורה הבאה:
me.info :הקובץ שם	-
-  מיקום הקובץ: בתיקיה של קובץ ההרצה ).exe( -  תוכן הקובץ:
שורה ראשונה: שם
שורה שניה: מזהה ייחודי בייצוג ASCII כאשר כל שני תווים מייצגים ערך hex בעל 8 סיביות. שורה שלישית: מפתח פרטי שנוצר בריצה הראשונה של התוכנית בפורמט בסיס .64
לדוגמא:


נתונים
הלקוח ישמור את נתוני הלקוחות (מזהה ייחודי, שם, מפתח ציבורי ומפתח סימטרי) בזיכרון )RAM(


אופן פעולת הלקוח
הלקוח יציג למשתמש את התפריט כדלהלן וימתין לקלט מהמשתמש במצב מסוף )stdin( בלולאה אין סופית.


שגיאה מצד השרת
בכל מקרה של שגיאה הלקוח ידפיס למסך הודעה: error" an with responded "server ויחכה לקלט הבא.


פעולות אפשריות

בקשת רישום – קלט "110"
.1  הלקוח יקלוט שם משתמש מהמסוף וישלח בקשת רישום לשרת.
.2  הלקוח ישמור בקובץ בשם me.info את השם והמזהה הייחודי שיקבל מהשרת.
שימו לב! במידה והקובץ כבר קיים הלקוח לא יאפשר בקשת רישום וידפיס שגיאה למסוף.

בקשת רשימת לקוחות – קלט "120"
.1 הלקוח ישלח בקשת רשימת לקוחות לשרת. יפענח את התשובה וידפיס למסך את שמות רשימת הלקוחות
 
בקשת מפתח ציבורי – קלט "130"
.1  הלקוח ישלח בקשת מפתח ציבורי לשרת.


בקשת שליפת הודעות ממתינות – קלט "140"
.1 הלקוח ישלח בקשת שליפת הודעות ממתינות לשרת. יפענח את התשובה וידפיס למסך את ההודעות בצורה הבאה:

א. עבור סוג הודעה "בקשת מפתח סימטרי" יש לכתוב בתוכן ההודעה: " for Request
"symmetric key
ב. עבור סוג הודעה "שליחת מפתח סימטרי" יש לכתוב בתוכן ההודעה: " key symmetric ."received בנוסף, תוכנת הלקוח תשמור בזיכרון את המפתח הסימטרי עבור לקוח זה.
ג.  עבור סוג הודעה "שליחת הודעת טקסט" יש לפענח את המסר באמצעות המפתח הסימטרי ולהציג את ההודעה. אם לא קיים מפתח סימטרי או שאינו תקין, יש לכתוב
"can’t decrypt message"

בקשת שליחת הודעה – קלט "150"
.1 הלקוח ימתין לקליטת שם משתמש היעד מהמסוף .2 הלקוח ימתין לקליטת הודעת טקסט
.3  הלקוח ישלח בקשת "שליחת הודעה" מסוג "שליחת הודעת טקסט" לשרת.


בקשת קבלת מפתח סימטרי – קלט "151"
.1  הלקוח ימתין לקליטת שם משתמש היעד מהמסוף
.2  הלקוח ישלח בקשת "שליחת הודעה" מסוג מפתח סימטרי.


בקשת שליחת מפתח סימטרי – קלט "152"
.1  הלקוח ימתין לקליטת שם משתמש היעד מהמסוף
.2 הלקוח ייצר מפתח סימטרי. ישמור אותו בזיכרון עבור לקוח היעד וישלח בקשת "שליחת הודעה" מסוג שליחת מפתח סימטרי.


*בונוס 10( נקודות*)
בקשת שליחת קובץ – קלט "153"
.1  הלקוח ימתין לקליטת שם משתמש היעד מהמסוף
.2  הלקוח ימתין לקליטת שם קובץ (כולל הנתיב המלא)
- אין להוסיף תמיכה ב- Unicode (כלומר, רק תווי )ascii
- במידה והקובץ לא נמצא או שהנתיב המוזן לא תקין, יש להדפיס שגיאה found" not "file
 
.3  הלקוח ישלח בקשת "שליחת הודעה" מסוג "שליחת קובץ" לשרת.

שימו לב!
-  יש להוסיף לתפריט את האפשרות: file a Send 153)
-  בעת קבלת הודעת  "שליחת קובץ" יש לפענח את המסר באמצעות המפתח הסימטרי, לשמור את הקובץ בשם זמני בתיקיית %TMP% ולהציג את הנתיב המלא לקובץ במקום .Content
-  גירסת הלקוח תהיה 2


יציאה – קלט תו "0"
.1  הלקוח ישחרר את משאבי מערכת ויסיים את ריצתו.

פרוטוקול התקשורת




 


little
 

הפרוטוקול הוא בינארי וממומש מעל .TCP
כל השדות המספריים חייבים להיות עם ערכים גדולים מאפס )unsigned( ומיוצגים כ-
endian
 
כללי
-
-
 
-  פרוטוקול זה תומך בבקשות לשרת ותשובות ללקוח. בקשות או תשובות יכולות להכיל "הודעה." -  הודעה עוברת בין לקוחות


זכרו! הפרוטוקול מחייב  ולא ניתן לעשות בו שינויים. כפועל יוצא, כל שרת ולקוח המממשים את הפרוטוקול יכולים לעבוד אחד מול השני.


רישום למערכת
.1 כל לקוח שמתחבר בפעם הראשונה נרשם בשירות עם שם (מחרוזת באורך מקסימלי של 255 בתים) ומעביר את המפתח הציבורי שלו
.2  השרת יחזיר ללקוח מזהה ייחודי שנוצר עבורו או שגיאה אם השם כבר קיים בבסיס הנתונים.

בקשות מהשרת
.1 לקוח יכול לבקש את רשימת המשתמשים האחרים .2  לקוח יכול לבקש מפתח ציבורי של לקוח מסויים
.3 לקוח יכול לבקש את כל ההודעות המחכות לו .4 לקוח יכול לשלוח הודעה ללקוח אחר


החלפת הודעות
.1  לקוח A מבקש מהשרת את המפתח הציבורי של לקוח B
 
.2 לקוח A שולח הודעה (דרך השרת) ללקוח B מסוג "בקשת מפתח הצפנה סימטרי" ההודעה מוצפנת ע"י המפתח הציבורי של B
.3  השרת מקבל את ההודעה ושומר אותה
.4  לקוח B מושך מהשרת את ההודעות הממתינות לו
.5  לקוח B מפענח את ההודעה באמצעות המפתח הפרטי
.6  לקוח B מבקש מהשרת את המפתח הציבורי של לקוח A
.7  לקוח B שולח תשובה מסוג "מפתח הצפנה סימטרי" ללקוח A
התשובה מוצפנת ע"י המפתח הציבורי של A
.8  השרת מקבל את ההודעה ושומר אותה
.9  לקוח A מושך מהשרת את ההודעות הממתינות לו
.10 לקוח A מפענח את ההודעה באמצעות המפתח הפרטי
.11 כעת, לקוח A ולקוח B יכולים לשוחח באמצעות מפתח הצפנה סימטרי







Figure 2 החלפת הודעות בין לקוח A ללקוח B
 
פרטי הפרוטוקול

בקשות
מבנה בקשה מהלקוח לשרת. השרת יפענח את התוכן )payload( לפי קוד הבקשה.

בקשה לשרת

משמעות	גודל	שדה	Request
מזהה ייחודי עבור כל לקוח	16 בתים 128( ביט)	Client ID	כותרת
)Header(
מספר גירסת לקוח	בית	Version	
קוד בקשה	2 בתים	Code	
גודל תוכן הבקשה	4 בתים	Payload size	
תוכן הבקשה.
משתנה בהתאם לבקשה	משתנה	payload	תוכן
)payload(


)payload( תוכן
התוכן משתנה בהתאם לבקשה. לכל בקשה מבנה שונה.

קוד בקשה 600 – רישום

משמעות	גודל	שדה
מחרוזת ASCII המייצגת שם משתמש. כולל תו מסיים! ( null
)terminated	255 בתים	Name
מפתח ציבורי של לקוח	160 בתים	Public Key
* שימו לב: השרת יתעלם מהשדה ID Client

קוד בקשה 601 – רשימת משתמשים
Payload size=0 שדה .קיים לא payload שדה

קוד בקשה 602 – שליפת מפתח ציבורי של לקוח

משמעות	גודל	שדה
מזהה ייחודי של לקוח	16 בתים	Client ID

קוד בקשה 603 – שליחת הודעה ללקוח

משמעות	גודל	שדה
מזהה ייחודי של לקוח היעד	16 בתים	Client ID
סוג ההודעה ללקוח	בית	Message Type
גודל תוכן ההודעה	4 בתים	Content Size
תוכן ההודעה.
מוצפן ע"י המפתח הציבורי של לקוח היעד או ע"י מפתח סימטרי.
תלוי בסוג ההודעה.	משתנה	Message Content
* סוגי ההודעות מפורטים בהמשך
 
קוד בקשה 604 – שליפת הודעות ממתינות
Payload size=0 שדה .קיים לא payload שדה


סוג ההודעה ללקוח Type( )Message
לקוח יכול לשלוח הודעות שונות ללקוח אחר.


סוג ההודעה 1 – בקשת מפתח סימטרי תוכן ההודעה ריק. שדה Size=0 Content

סוג ההודעה 2 – שליחת מפתח סימטרי
שדה Content Message מכיל מפתח סימטרי מוצפן ע"י מפתח ציבורי של לקוח היעד


סוג ההודעה 3 – שליחת הודעת טקסט
שדה Content Message מכיל טקסט מוצפן ע"י מפתח סימטרי.

סוג ההודעה 4 – שליחת קובץ
יש לממש רק אם בחרתם להוסיף את אפשרות שליחת הקובץ בצד הלקוח (סעיף בונוס.)
שדה Content Message מכיל קובץ מוצפן ע"י מפתח סימטרי.



תשובות

תשובה מהשרת

משמעות	גודל	שדה	Response
מספר גירסת שרת	בית	Version	כותרת
)Header(
קוד התשובה	2 בתים	Code	
גודל תוכן התשובה	4 בתים	Payload size	
תוכן התשובה.
משתנה בהתאם לתשובה	משתנה	payload	תוכן
)payload(


)payload( תוכן
קוד תשובה 2100 – רישום הצליח

משמעות	גודל	שדה
מזהה ייחודי של לקוח	16 בתים	Client ID
 
קוד תשובה 2101 – רשימת המשתמשים

משמעות	גודל	שדה
מזהה ייחודי של לקוח	16 בתים	Client ID
מחרוזת ASCII המייצגת שם משתמש. כולל תו מסיים! ( null
)terminated	255 בתים	Client Name
חשוב: רשימת משתמשים לא תכלול את המשתמש שביקש אותה. כמו כן, הרשימה עשויה לכלול משתמשים רבים. הם יופיעו אחד אחרי השני וניתן לחשב את מספרם ע"י הנוסחה:
Payload Size / (16+255)

קוד תשובה 2102 – מפתח ציבורי

משמעות	גודל	שדה
מזהה ייחודי של לקוח	16 בתים	Client ID
מפתח ציבורי של לקוח	160 בתים	Public Key

קוד תשובה 2103 – הודעה ללקוח נשלחה (שמורה אצל השרת – לא בהכרח נקראה)

משמעות	גודל	שדה
מזהה ייחודי של לקוח היעד	16 בתים	Client ID
מזהה ייחודי של הודעה	4 בתים	Message ID

קוד תשובה 2104 – שליפת הודעות ממתינות

משמעות	גודל	שדה
מזהה ייחודי של הלקוח ממנו
הגיעה ההודעה	16 בתים	Client ID
מזהה ייחודי של הודעה	4 בתים	Message ID
סוג ההודעה ללקוח	בית	Message Type
גודל ההודעה	4 בתים	Message Size
תוכן ההודעה	משתנה	Content
חשוב: יכולות להיות הודעות ממתינות רבות. הן תופענה אחת אחרי השניה ברצף



קוד תשובה 9000 – שגיאה כללית
Payload size=0 שדה .קיים לא payload שדה
 
הצפנה
פרוטוקול התקשורת משתמש בהצפנה סימטרית על מנת לקודד את ההודעה בין הלקוחות ובהצפנה אסימטרית על מנת להחליף מפתח בין הלקוחות.
בתרגיל זה השתמשו בספריה ,Crypto++4 גרסה מומלצת: 8.80 (ראו נספח א)'


הצפנה סימטרית
עבור הצפנה סימטרית השתמשו ב- .AES-CBC
אורך המפתח 128 ביט. ניתן להניח שה- IV מאופס תמיד (הזיכרון מלא באפסים.)
שימוש כזה ב- IV לא בטוח אם משתמשים באותו מפתח בכל פעם, אך לצורך הממן הוא מספק.

הצפנה אסימטרית
עבור הצפנה אסימטרית השתמשו ב- .RSA אורך המפתחות 1024 ביט.
שימו לב: הספריה Crypto++ מחזיקה מפתחות ציבוריים בפורמט .X5095 פורמט זה מכיל Header לפני המפתח עצמו וערכים נוספים. לכן, גודלו הסופי (בצורה בינארית) הוא 160 בתים (עבור מפתחות בגודל שונה גודלו הסופי של המפתח ישתנה בהתאם.)

דגשים לפיתוח
.1 העבודה אישית! אסור לחלוק קוד ו/או להעזר במקורות חיצוניים. זה כולל ספריות, קבצים שלמים וחלקי קוד (מותר להשתמש אך ורק בספריות שנלמדו בקורס ו/או מוזכרות במטלה.)
.2 מומלץ לעבוד עם מערכת לניהול קוד (כדוגמת גיט )6 .3  עבדו באופן מודולרי ובדקו את עצמכם כל הזמן
א. זהו את המחלקות והפונקציות החשובות ב. בצד השרת:
כיתבו קוד לטיפול בבקשה אחת. הוסיפו תמיכה בריבוי לקוחות בשלב מאוחר יותר ג. בצד הלקוח:
ממשו את הרכיבים הגדולים באופן בלתי תלוי בחלקים אחרים של המערכת (תקשורת, הצפנה, פרוטוקול וכו.)'
.4  ממשו קוד לבדיקה כבר בשלבים מוקדמים של הפרוייקט
א.  בצד השרת:
השתמשו בהדפסות למסך או בכתיבה ללוג כדי לעקוב אחרי התקשורת. תוכלו גם לטעון את המודול לתוך ה- interpreter ולעבוד באופן דינמי.
ב.  בצד הלקוח:
כיתבו פונקציות קטנות שבודקות חלקים נפרדים של המערכת. השתמשו בפונקציות הללו תוך כדי כתיבת הקוד עצמו.
.5  כתיבת הקוד
א. יש לממש מחלקות ולהשתמש בעקרונות תכנות מונחה עצמים, כלומר יש להשתמש בכימוס, ירושה ופולימורפיזם
ב. שימו לב לייצוג ערכים בזיכרון כ- little-endian או big-endian ג. הקפידו על תיעוד של הקוד )comments(

 /https://www.cryptopp.com 4
 https://en.wikipedia.org/wiki/X.509 5
 https://www.atlassian.com/git/tutorials/what-is-version-control 6
 
ד.  תנו שמות משמעותיים למשתנים, פונקציות ומחלקות. המנעו ממספרי קסם!
ה. הודעה יכולה להיות גדולה מאוד (בגודל דינמי.) חשבו על הדרך הנכונה ביותר לקבל ולשלוח כמות מידע גדולה.
.6  טיפול בשגיאות יעשה באמצעות חריגות
א.  יש לזרוק חריגות במקומות מתאימים, לתפוס ולטפל בהתאם.
ב.  במידה ולא ניתן להמשיך יש להציג הודעה ידידותית למשתמש ולצאת בצורה מסודרת (לדוגמא כשמנסים לקרוא קובץ לא קיים יש לצאת עם הודעה ידידותית ומסודרת ולהמנע מתעופה עם שגיאה.)
שימו לב! זה נכון ל- C++ ולפייתון.
.7  אבטחת מידע – חשבו לאורך כל הדרך על כתיבת קוד בטוח לפי העקרונות שלמדתם: האם בדקתם את הקלט? איך נעשה שימוש בזיכרון דינמי? האם מתבצעת המרת טיפוסים )casting( וכו..'
.8  לפני ההגשה
א. בדקו שהפרוייקט מתקמפל ורץ בצורה תקינה ללא קריסות או תלויות בספריות שונות (למעט הספריות הנדרשות לתרגיל)
ב. מומלץ לייצר תיקיה חדשה ולהעתיק לשם את הקבצים המיועדים לשליחה. לייצר פרוייקט VS חדש, לקמפל ולהריץ
ג. העבודה תבדק על מ"ה חלונות עם 2019 Community Studio Visual (מומלץ לעבוד בסביבה זו בזמן הפיתוח)


דגשים לקוד שרת:
.1  השתמשו בפייתון גירסה 3
.2  עשו שימוש בספריות פייתון הסטנדרטיות בלבד!
.3 תוכלו להעזר בספריה struct על מנת לעבוד עם נתוני התקשורת בנוחות

דגשים לקוד לקוח:
.1 יש להשתמש בעקרונות תכנות מונחה עצמים (כלומר יש להשתמש במחלקות, בירושה ופולימורפיזם)
.2  מומלץ (אבל לא חובה) לעשות שימוש בספריות STL
.3 ניתן ורצוי להשתמש ביכולות C++11 (לדוגמא פונקציות מסוג למדה, שימוש ב- auto וכו.)..' .4 למימוש התקשורת עשו שימוש ב- winsock או בספרית boost


 

קבצי השרת והלקוח יהיו בתיקיות נפרדות: client עבור הלקוח ו- server עבור השרת. תיקיות אלו ימצאו בתיקיה ראשית בשם src
עליכם להגיש רק את קבצי הקוד (כלומר קבצי .py עבור פייתון ו- .h ו- .cpp עבור )c++
שימו לב! על התוכנית להתקמפל ולרוץ בצורה תקינה (ללא צורך בתוספות קבצים וללא קריסות) בקוד השרת יש לכלול פונקציה בשם .main פונקציה זו תהיה הפונקציה הראשית של התוכנית והיא תעבוד לפי אופן פעולת השרת המפורט לעיל.
טיפ:
תוכלו להשתמש במנגנון הבא כדי לאפשר עבודה אינטראקטיבית וגם הרצה של הקוד
 
הגשה
.1
.2
.3
.4
 
if   name	== "  main  ":
 
שאלה 2 )20%(
עליכם לנתח את הפרוטוקול המוצע בשאלה 1 ולמצוא בו חולשות פוטנציאליות. יש להגיש  מסמך מחקר המפרט את החולשות שמצאתם, התקפות אפשריות והצעה לתיקון.


הגשה
. pdf או word מסמך

הערה:
את כלל קבצי המערכת יש לארוז לקובץ zip ובתוכו כאמור: תיקית src המכילה:
תיקית client עבור קבצי הלקוח תיקית server עבור קבצי השרת
מסמך מחקר





בהצלחה!
 
נספח א' – ספריית הצפנה Crypto++


לנוחיותכם וכדי להקל עליכם את העבודה עם ספריית Crypto++ עטפנו את הפונקציונליות החשובה לממן בארבע מחלקות (ניתן למצוא את הקוד באתר הקורס:)


קידוד ופענוח של Base64	Base64Wrapper
- הצפנה ופענוח באמצעות מפתח סימטרי .)AES(
- ניתן גם לייצר מפתח סימטרי.	AESWrapper
הצפנה באמצעות מפתח ציבורי (מפתח ציבורי מיוצר ע"י המחלקה
)RSAPrivateWrapper	RSAPublicWrapper
- פענוח באמצעות מפתח פרטי.
- ניתן גם לייצר זוג מפתחות חדש (פרטי / ציבורי)	RSAPrivateWrapper

שימו לב:
.1 מחלקות אלו עוטפות את הספריה Crypto++ ולכן עדיין יש צורך להתקין את הספריה עצמה. .2  אין חובה להשתמש במחלקות אלו אם כי זה מומלץ על מנת לחסוך זמן פיתוח. בכל מקרה יש
להשתמש בספריה .Crypto++
.3  ניתן לשנות ולהרחיב את המחלקות במידת הצורך.
